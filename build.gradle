plugins {
	id 'net.fabricmc.fabric-loom' version '1.14-SNAPSHOT'
	id 'maven-publish'
}

version = project.mod_version
group = project.maven_group

base {
	archivesName = project.archives_base_name
}

repositories {
	// Add repositories to retrieve artifacts from in here.
	// You should only use this when depending on other mods because
	// Loom adds the essential maven repositories to download Minecraft and libraries from automatically.
	// See https://docs.gradle.org/current/userguide/declaring_repositories.html
	// for more information about repositories.
	mavenCentral()
	maven {
		name = 'Fabric'
		url = 'https://maven.fabricmc.net/'
	}
}

loom {
	// Note: splitEnvironmentSourceSets() not used because Vitra is client-only
	// All code remains in src/main/ for simplicity
}

dependencies {
	// To change the versions see the gradle.properties file
	minecraft "com.mojang:minecraft:${project.minecraft_version}"
	// No mappings needed for unobfuscated Minecraft 26.1+
	implementation "net.fabricmc:fabric-loader:${project.loader_version}"

	// Fabric API. This is technically optional, but you probably want it anyway.
	implementation "net.fabricmc.fabric-api:fabric-api:${project.fabric_version}"

	// LWJGL dependencies
	implementation "org.lwjgl:lwjgl:${lwjgl_version}"
	implementation "org.lwjgl:lwjgl-glfw:${lwjgl_version}"

	include "org.lwjgl:lwjgl:${lwjgl_version}"
	include "org.lwjgl:lwjgl-glfw:${lwjgl_version}"

	// Platform-specific natives (Windows only for D3D11)
	runtimeOnly "org.lwjgl:lwjgl:${lwjgl_version}:natives-windows"
	runtimeOnly "org.lwjgl:lwjgl-glfw:${lwjgl_version}:natives-windows"

	include "org.lwjgl:lwjgl:${lwjgl_version}:natives-windows"
	include "org.lwjgl:lwjgl-glfw:${lwjgl_version}:natives-windows"

	// Optional JNA dependency for future cross-platform native access
	// Currently using JNI for Windows D3D11, but JNA could be used for other platforms
	implementation "net.java.dev.jna:jna:${jna_version}"

	// SLF4J for logging
	implementation "org.slf4j:slf4j-api:${slf4j_version}"

}

processResources {
	inputs.property "version", project.version

	filesMatching("fabric.mod.json") {
		expand "version": inputs.properties.version
	}
}

tasks.withType(JavaCompile).configureEach {
	it.options.release = 25
	// Disable incremental compilation to ensure changes are always recompiled
	// This prevents stale class files from being used during development
	it.options.incremental = false
}

java {
	// Loom will automatically attach sourcesJar to a RemapSourcesJar task and to the "build" task
	// if it is present.
	// If you remove this line, sources will not be generated.
	withSourcesJar()

	sourceCompatibility = JavaVersion.VERSION_25
	targetCompatibility = JavaVersion.VERSION_25
}

// ============================================================================
// HLSL Shader Compilation Task
// ============================================================================
// Compiles HLSL shaders to .cso (Compiled Shader Object) files using fxc.exe
// These precompiled shaders are loaded at runtime for faster startup
task compileShaders {
	description = 'Compiles HLSL shaders to .cso files using fxc.exe'
	group = 'build'

	// Only compile on Windows (fxc.exe is Windows-only)
	onlyIf { System.getProperty('os.name').toLowerCase().contains('windows') }

	doFirst {
		// Create output directory
		def compiledDir = file("src/main/resources/assets/vitra/shaders/compiled")
		compiledDir.mkdirs()

		// Find fxc.exe in Windows SDK
		def programFiles = System.env['ProgramFiles(x86)'] ?: 'C:\\Program Files (x86)'
		def windowsKitsDir = file("${programFiles}\\Windows Kits\\10")

		if (!windowsKitsDir.exists()) {
			throw new GradleException("Windows 10 SDK not found. Please install Windows SDK with D3D support.")
		}

		// Find the latest SDK version with fxc.exe
		def fxcExe = null
		windowsKitsDir.eachDir { sdkDir ->
			if (sdkDir.name == 'bin') {
				sdkDir.eachDir { versionDir ->
					def fxcPath = file("${versionDir}/x64/fxc.exe")
					if (fxcPath.exists()) {
						fxcExe = fxcPath
					}
				}
			}
		}

		if (fxcExe == null) {
			throw new GradleException("fxc.exe not found in Windows SDK. Please install Windows SDK with D3D support.")
		}

		println "Using D3D Shader Compiler: ${fxcExe}"

		// Find all shader files in the core shaders directory
		def coreShaderDir = file("src/main/resources/assets/vitra/shaders/core")
		def shaders = []
		
		coreShaderDir.eachDir { shaderDir ->
			def shaderName = shaderDir.name
			def vshFile = file("${shaderDir}/${shaderName}.vsh")
			def fshFile = file("${shaderDir}/${shaderName}.fsh")
			
			if (vshFile.exists()) {
				shaders.add([name: shaderName, type: 'vs', file: vshFile])
			}
			if (fshFile.exists()) {
				shaders.add([name: shaderName, type: 'ps', file: fshFile])
			}
		}

		println "Found ${shaders.size()} shaders to compile"

		def successCount = 0
		def failCount = 0
		def failedShaders = []

		// Compile each shader
		shaders.each { shader ->
			def shaderType = (shader.type == 'vs') ? 'vertex' : 'pixel'
			def target = (shader.type == 'vs') ? 'vs_5_0' : 'ps_5_0'
			def outputFile = file("${compiledDir}/${shader.name}_${shader.type}.cso")

			println "Compiling ${shaderType} shader: ${shader.name} -> ${outputFile.name}"

			// Compile using fxc.exe
			// /T = target profile, /E = entry point, /Fo = output file
			// /I = include directory, /nologo = suppress copyright
			// Note: We don't use /WX (warnings as errors) as some shaders have benign warnings
			def result = ["cmd", "/c",
				"\"${fxcExe}\"",
				"/T", target,          // Target shader model (vs_5_0 or ps_5_0)
				"/E", "main",          // Entry point function
				"/Fo", outputFile.absolutePath,  // Output file
				"/I", file("src/main/resources/assets/vitra/shaders/core").absolutePath,  // Include directory
				"/nologo",             // Suppress copyright message
				"/O3",                 // Optimization level 3
				shader.file.absolutePath
			].execute()

			result.waitFor()

			if (result.exitValue() != 0) {
				failCount++
				def errorText = result.err.text
				failedShaders.add("${shader.name}.${shader.type == 'vs' ? 'vsh' : 'fsh'}: ${errorText}")
				println "  FAILED: ${errorText}"
			} else {
				successCount++
				println "  OK"
			}
		}

		println ""
		println "Shader compilation complete: ${successCount} succeeded, ${failCount} failed"
		
		if (failCount > 0) {
			println "Failed shaders:"
			failedShaders.each { println "  - ${it}" }
			// Don't fail the build - some shaders may have issues but others can still work
			println "WARNING: Some shaders failed to compile. The game may not render correctly."
		} else {
			println "All shaders compiled successfully to: ${compiledDir}"
		}
	}
}


// ============================================================================
// Native Library Compilation Tasks
// ============================================================================

// RenderDoc configuration (optional - only required for RenderDoc integration)
// RenderDoc.dll will be loaded dynamically at runtime if present
// No build-time dependency required for RenderDoc integration

// D3D 11 native library compilation task - Incremental
task compileNativeDX11 {
	description = 'Compiles DirectX 11 native library (incremental)'
	group = 'build'
	
	// Only compile on Windows
	onlyIf { !project.hasProperty('skipNative') && System.getProperty('os.name').toLowerCase().contains('windows') }
	
	// Define inputs - when these change, task will re-run
	inputs.files(fileTree('src/main/cpp') { include '**/*.cpp' })
	inputs.files(fileTree('src/main/include') { include '**/*.h' })
	
	// Define outputs - if these exist and inputs haven't changed, task is UP-TO-DATE
	outputs.file("$buildDir/native/vitra-d3d11.dll")
	outputs.file("$buildDir/native/vitra-d3d11.lib")
	
	doLast {
		// Create output directory
		file("$buildDir/native").mkdirs()

		// Check for Visual Studio build tools - try both Program Files locations
		def vsWhere = null
		def programFilesX86 = System.env['ProgramFiles(x86)'] ?: 'C:\\Program Files (x86)'
		def programFiles = System.env['ProgramFiles'] ?: 'C:\\Program Files'

		if (file("${programFilesX86}\\Microsoft Visual Studio\\Installer\\vswhere.exe").exists()) {
			vsWhere = "${programFilesX86}\\Microsoft Visual Studio\\Installer\\vswhere.exe"
		} else if (file("${programFiles}\\Microsoft Visual Studio\\Installer\\vswhere.exe").exists()) {
			vsWhere = "${programFiles}\\Microsoft Visual Studio\\Installer\\vswhere.exe"
		}

		if (vsWhere == null) {
			throw new GradleException("Visual Studio Build Tools not found. Please install Visual Studio 2019/2022 with C++ support.")
		}

		def vsPath = ["cmd", "/c", vsWhere, "-latest", "-products", "*", "-requires", "Microsoft.VisualStudio.Component.VC.Tools.x86.x64", "-property", "installationPath"].execute().text.trim()
		if (vsPath.isEmpty()) {
			throw new GradleException("Visual Studio C++ build tools not found.")
		}

		def vcvarsPath = "${vsPath}\\VC\\Auxiliary\\Build\\vcvars64.bat"
		if (!file(vcvarsPath).exists()) {
			throw new GradleException("vcvars64.bat not found at: ${vcvarsPath}")
		}

		println "Using vswhere: ${vsWhere}"
		println "Compiling D3D 11 native library with Visual Studio at: ${vsPath}"
		println "RenderDoc integration: Enabled (runtime dynamic loading)"

		// Build the command dynamically with the detected VS path
		def compileCommand = "call \"${vcvarsPath}\" && " +
			"cl /LD /EHsc /D_DEBUG /MDd /I\"src/main/include\" " +
			"/I\"%JAVA_HOME%\\include\" /I\"%JAVA_HOME%\\include\\win32\" " +
			"/I\"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\" " +
			"/I\"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\um\" " +
			"/I\"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\shared\" " +
			"\"src/main/cpp/vitra_d3d11.cpp\" " +
			"/Fe:\"$buildDir/native/vitra-d3d11.dll\" " +
			"/link /LIBPATH:\"libs/x64\" /LIBPATH:\"C:\\Program Files (x86)\\Windows Kits\\10\\Lib\\10.0.26100.0\\ucrt\\x64\" " +
			"/LIBPATH:\"C:\\Program Files (x86)\\Windows Kits\\10\\Lib\\10.0.26100.0\\um\\x64\" " +
			"d3d11.lib dxgi.lib d3dcompiler.lib dxguid.lib user32.lib Ole32.lib Shell32.lib"

		// Execute the command directly
		def proc = ["cmd", "/c", compileCommand].execute(null, projectDir)
		proc.waitFor()

		if (proc.exitValue() != 0) {
			println "STDOUT: ${proc.text}"
			println "STDERR: ${proc.err.text}"
			throw new GradleException("D3D11 native compilation failed with exit code: ${proc.exitValue()}")
		}

		println "D3D 11 native library compiled successfully: ${file("$buildDir/native/vitra-d3d11.dll")}"
	}
}

// D3D 12 Ultimate native library compilation task - Incremental
task compileNativeDX12 {
	description = 'Compiles DirectX 12 Ultimate native library (incremental)'
	group = 'build'
	
	// Only compile on Windows
	onlyIf { !project.hasProperty('skipNative') && System.getProperty('os.name').toLowerCase().contains('windows') }
	
	// Define inputs - when these change, task will re-run
	inputs.files(fileTree('src/main/cpp') { include '**/vitra_d3d12.cpp' })
	inputs.files(fileTree('src/main/include') { include '**/*.h' })
	inputs.files(fileTree('src/main/external/D3D12MA') { include '**/*.cpp', '**/*.h' })
	
	// Define outputs - if these exist and inputs haven't changed, task is UP-TO-DATE
	outputs.file("$buildDir/native/vitra-d3d12.dll")
	outputs.file("$buildDir/native/vitra-d3d12.lib")

	doLast {
		// Create output directory
		file("$buildDir/native").mkdirs()

		// Check for Visual Studio build tools with Windows 10 SDK - try both Program Files locations
		def vsWhere = null
		def programFilesX86 = System.env['ProgramFiles(x86)'] ?: 'C:\\Program Files (x86)'
		def programFiles = System.env['ProgramFiles'] ?: 'C:\\Program Files'

		if (file("${programFilesX86}\\Microsoft Visual Studio\\Installer\\vswhere.exe").exists()) {
			vsWhere = "${programFilesX86}\\Microsoft Visual Studio\\Installer\\vswhere.exe"
		} else if (file("${programFiles}\\Microsoft Visual Studio\\Installer\\vswhere.exe").exists()) {
			vsWhere = "${programFiles}\\Microsoft Visual Studio\\Installer\\vswhere.exe"
		}

		if (vsWhere == null) {
			throw new GradleException("Visual Studio Build Tools not found. Please install Visual Studio 2019/2022 with C++ support.")
		}

		def vsPath = ["cmd", "/c", vsWhere, "-latest", "-products", "*", "-requires", "Microsoft.VisualStudio.Component.VC.Tools.x86.x64", "-property", "installationPath"].execute().text.trim()
		if (vsPath.isEmpty()) {
			throw new GradleException("Visual Studio C++ build tools not found.")
		}

		def vcvarsPath = "${vsPath}\\VC\\Auxiliary\\Build\\vcvars64.bat"
		if (!file(vcvarsPath).exists()) {
			throw new GradleException("vcvars64.bat not found at: ${vcvarsPath}")
		}

		println "Using vswhere: ${vsWhere}"
		println "Compiling D3D 12 Ultimate native library with Visual Studio at: ${vsPath}"
		println "RenderDoc integration: Enabled (runtime dynamic loading)"

		// Build the command dynamically with the detected VS path
		def compileCommand = "call \"${vcvarsPath}\" && " +
			"cl /LD /EHsc /std:c++20 /I\"src/main/include\" /I\"src/main/external/D3D12MA\" " +
			"/I\"%JAVA_HOME%\\include\" /I\"%JAVA_HOME%\\include\\win32\" " +
			"/DVITRA_D3D12MA_AVAILABLE=1 " +
			"\"src/main/cpp/vitra_d3d12.cpp\" \"src/main/external/D3D12MA/D3D12MemAlloc.cpp\" " +
			"/Fe:\"$buildDir/native/vitra-d3d12.dll\" " +
			"/link /LIBPATH:\"libs/x64\" d3d12.lib dxgi.lib d3dcompiler.lib dxcompiler.lib user32.lib Ole32.lib Shell32.lib"

		// Execute the command directly
		def proc = ["cmd", "/c", compileCommand].execute(null, projectDir)
		proc.waitFor()

		if (proc.exitValue() != 0) {
			println "STDOUT: ${proc.text}"
			println "STDERR: ${proc.err.text}"
			throw new GradleException("D3D12 native compilation failed with exit code: ${proc.exitValue()}")
		}

		println "D3D 12 Ultimate native library compiled successfully: ${file("$buildDir/native/vitra-d3d12.dll")}"

		// Copy dxcompiler.dll dependency from Windows SDK to build/native
		def windowsKitsPath = "${System.env['ProgramFiles(x86)']}\\Windows Kits\\10"
		def dxcompilerSource = "${windowsKitsPath}\\bin\\10.0.26100.0\\x64\\dxcompiler.dll"

		if (file(dxcompilerSource).exists()) {
			copy {
				from dxcompilerSource
				into "$buildDir/native"
			}
			println "Copied dxcompiler.dll dependency to build/native"
		} else {
			println "WARNING: dxcompiler.dll not found at ${dxcompilerSource}"
			println "D3D 12 may fail to load. Please install Windows 10 SDK."
		}
	}
}

// Compile all native libraries
task compileNative {
	dependsOn compileNativeDX11, compileNativeDX12
}

// Copy native libraries to build/resources (incremental - only copies changed files)
task copyNative(type: Sync) {
	description = 'Copies native DLLs to build resources (incremental)'
	group = 'build'
	
	dependsOn compileNative
	onlyIf { !project.hasProperty('skipNative') && System.getProperty('os.name').toLowerCase().contains('windows') }

	from("$buildDir/native") {
		include "*.dll"
	}
	from("libs/x64") {
		include "*.dll"
	}
	into "$buildDir/resources/main/native/windows"
	
	// Sync preserves existing files not in source (preserve = true)
	// For complete replacement, Sync automatically handles incremental updates
	preserve {
		include '**/*'
		exclude 'vitra-d3d11.dll'
		exclude 'vitra-d3d12.dll'
		exclude 'dxcompiler.dll'
	}
	
	doFirst {
		file("$buildDir/resources/main/native/windows").mkdirs()
	}
}

// Also copy to src/main/resources for development (IDE usage) - incremental
task copyNativeToSrc(type: Sync) {
	description = 'Copies native DLLs to src/main/resources for IDE development (incremental)'
	group = 'build'
	
	dependsOn compileNative
	onlyIf { !project.hasProperty('skipNative') && System.getProperty('os.name').toLowerCase().contains('windows') }

	from("$buildDir/native") {
		include "*.dll"
	}
	from("libs/x64") {
		include "*.dll"
	}
	into "src/main/resources/native/windows"
	
	// Sync preserves existing files not in source
	preserve {
		include '**/*'
		exclude 'vitra-d3d11.dll'
		exclude 'vitra-d3d12.dll'
		exclude 'dxcompiler.dll'
	}
	
	doFirst {
		file("src/main/resources/native/windows").mkdirs()
	}
}

// Make processResources depend on copyNative, copyNativeToSrc, and compileShaders
// This ensures all shaders are precompiled and native libraries are available during build
processResources.dependsOn copyNative, copyNativeToSrc, compileShaders

// Make classes task depend on copyNativeToSrc for IDE development
classes.dependsOn copyNativeToSrc

// Make sourcesJar depend on copyNativeToSrc to ensure native libraries are copied first
sourcesJar.dependsOn copyNativeToSrc

// Make sure jar includes the native library
jar {
	dependsOn copyNative
	inputs.property "archivesName", project.base.archivesName

	from("LICENSE") {
		rename { "${it}_${inputs.properties.archivesName}"}
	}

	// Include native library if it exists
	from("$buildDir/resources/main") {
		include "native/windows/*.dll"
		into "native/windows"
	}
}

// configure the maven publication
publishing {
	publications {
		create("mavenJava", MavenPublication) {
			artifactId = project.archives_base_name
			from components.java
		}
	}

	// See https://docs.gradle.org/current/userguide/publishing_maven.html for information on how to set up publishing.
	repositories {
		// Add repositories to publish to here.
		// Notice: This block does NOT have the same function as the block in the top level.
		// The repositories here will be used for publishing your artifact, not for
		// retrieving dependencies.
	}
}
