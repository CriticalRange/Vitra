plugins {
	id 'fabric-loom' version '1.9.2'
	id 'maven-publish'
}

version = project.mod_version
group = project.maven_group

base {
	archivesName = project.archives_base_name
}

repositories {
	// Add repositories to retrieve artifacts from in here.
	// You should only use this when depending on other mods because
	// Loom adds the essential maven repositories to download Minecraft and libraries from automatically.
	// See https://docs.gradle.org/current/userguide/declaring_repositories.html
	// for more information about repositories.
	mavenCentral()
	maven {
		name = 'Fabric'
		url = 'https://maven.fabricmc.net/'
	}
}

loom {
	// Note: splitEnvironmentSourceSets() not used because Vitra is client-only
	// All code remains in src/main/ for simplicity
}

dependencies {
	// To change the versions see the gradle.properties file
	minecraft "com.mojang:minecraft:${project.minecraft_version}"
	mappings loom.officialMojangMappings()
	modImplementation "net.fabricmc:fabric-loader:${project.loader_version}"

	// Fabric API. This is technically optional, but you probably want it anyway.
	modImplementation "net.fabricmc.fabric-api:fabric-api:${project.fabric_version}"

	// LWJGL dependencies
	implementation "org.lwjgl:lwjgl:${lwjgl_version}"
	implementation "org.lwjgl:lwjgl-glfw:${lwjgl_version}"

	include "org.lwjgl:lwjgl:${lwjgl_version}"
	include "org.lwjgl:lwjgl-glfw:${lwjgl_version}"

	// Platform-specific natives (Windows only for DirectX 11)
	runtimeOnly "org.lwjgl:lwjgl:${lwjgl_version}:natives-windows"
	runtimeOnly "org.lwjgl:lwjgl-glfw:${lwjgl_version}:natives-windows"

	include "org.lwjgl:lwjgl:${lwjgl_version}:natives-windows"
	include "org.lwjgl:lwjgl-glfw:${lwjgl_version}:natives-windows"

	// Optional JNA dependency for future cross-platform native access
	// Currently using JNI for Windows DirectX 11, but JNA could be used for other platforms
	implementation "net.java.dev.jna:jna:${jna_version}"

	// SLF4J for logging
	implementation "org.slf4j:slf4j-api:${slf4j_version}"

}

processResources {
	inputs.property "version", project.version

	filesMatching("fabric.mod.json") {
		expand "version": inputs.properties.version
	}
}

tasks.withType(JavaCompile).configureEach {
	it.options.release = 21
}

java {
	// Loom will automatically attach sourcesJar to a RemapSourcesJar task and to the "build" task
	// if it is present.
	// If you remove this line, sources will not be generated.
	withSourcesJar()

	sourceCompatibility = JavaVersion.VERSION_21
	targetCompatibility = JavaVersion.VERSION_21
}

// ============================================================================
// HLSL Shader Compilation Task
// ============================================================================
// Compiles HLSL shaders using fxc.exe from Windows SDK
task compileShaders {
	description = 'Compiles HLSL shaders using fxc.exe'
	group = 'build'

	// Only compile on Windows
	onlyIf { System.getProperty('os.name').toLowerCase().contains('windows') }

	doFirst {
		// Create output directory
		def compiledDir = file("src/main/resources/shaders/compiled")
		compiledDir.mkdirs()

		// Find fxc.exe in Windows SDK
		def programFiles = System.env['ProgramFiles(x86)'] ?: 'C:\\Program Files (x86)'
		def windowsKitsDir = file("${programFiles}\\Windows Kits\\10")

		if (!windowsKitsDir.exists()) {
			throw new GradleException("Windows 10 SDK not found. Please install Windows SDK with DirectX support.")
		}

		// Find the latest SDK version with fxc.exe
		def fxcExe = null
		windowsKitsDir.eachDir { sdkDir ->
			if (sdkDir.name == 'bin') {
				sdkDir.eachDir { versionDir ->
					def fxcPath = file("${versionDir}/x64/fxc.exe")
					if (fxcPath.exists()) {
						fxcExe = fxcPath
					}
				}
			}
		}

		if (fxcExe == null) {
			throw new GradleException("fxc.exe not found in Windows SDK. Please install Windows SDK with DirectX support.")
		}

		println "Using DirectX Shader Compiler: ${fxcExe}"

		// Shader list to compile - extended set covering Minecraft 1.21+ pipelines
		def shaderNames = [
			'blit_screen',
			'entity',
			'glint',
			'gui',
			'panorama',
			'particle',
			'position',
			'position_color',
			'position_color_lightmap',
			'position_color_tex_lightmap',
			'position_tex',
			'position_tex_color',
			'rendertype_beacon_beam',
			'rendertype_clouds',
			'rendertype_crumbling',
			'rendertype_end_portal',
			'rendertype_entity_alpha',
			'rendertype_entity_decal',
			'rendertype_entity_shadow',
			'rendertype_item_entity_translucent_cull',
			'rendertype_leash',
			'rendertype_lightning',
			'rendertype_lines',
			'rendertype_outline',
			'rendertype_text',
			'rendertype_text_background',
			'rendertype_text_background_see_through',
			'rendertype_text_intensity',
			'rendertype_text_intensity_see_through',
			'rendertype_text_see_through',
			'rendertype_translucent_moving_block',
			'rendertype_water_mask',
			'rendertype_world_border',
			'sky',
			'stars',
			'terrain'
		]

		// Generate vertex and pixel shader entries for each shader
		def shaders = []
		shaderNames.each { name ->
			shaders.add([name: name, type: 'vs'])
			shaders.add([name: name, type: 'ps'])
		}

		// Compile each shader
		shaders.each { shader ->
			def shaderType = (shader.type == 'vs') ? 'vertex' : 'pixel'
			def shaderExt = (shader.type == 'vs') ? 'vsh' : 'fsh'
			def target = (shader.type == 'vs') ? 'vs_5_0' : 'ps_5_0'
			def inputFile = file("src/main/resources/shaders/hlsl/${shader.name}.${shaderExt}")
			def outputFile = file("${compiledDir}/${shader.name}_${shader.type}.cso")

			println "Compiling ${shaderType} shader: ${shader.name}.${shaderExt} -> ${outputFile.name}"

			// Compile using fxc.exe
			def result = ["cmd", "/c",
				"\"${fxcExe}\"",
				"/T", target,          // Target shader model (vs_5_0 or ps_5_0)
				"/E", "main",          // Entry point function
				"/Fo", outputFile.absolutePath,  // Output file
				"/I", file("src/main/resources/shaders/hlsl").absolutePath,  // Include directory
				"/nologo",             // Suppress copyright message
				"/O3",                 // Optimization level 3
				"/WX",                 // Treat warnings as errors
				inputFile.absolutePath
			].execute()

			result.waitFor()

			if (result.exitValue() != 0) {
				throw new GradleException("Failed to compile shader: ${shader.name}.${shaderExt}\nError: ${result.err.text}")
			}
		}

		println "All shaders compiled successfully to: ${compiledDir}"
	}
}

// ============================================================================
// Native Library Compilation Tasks
// ============================================================================

// RenderDoc configuration (optional - only required for RenderDoc integration)
// RenderDoc.dll will be loaded dynamically at runtime if present
// No build-time dependency required for RenderDoc integration

// DirectX 11 native library compilation task
task compileNativeDX11(type: Exec) {
	// Only compile on Windows
	onlyIf { !project.hasProperty('skipNative') && System.getProperty('os.name').toLowerCase().contains('windows') }

	doFirst {
		// Create output directory
		file("$buildDir/native").mkdirs()

		// Check for Visual Studio build tools
		def vsWhere = "${System.env['ProgramFiles(x86)']}\\Microsoft Visual Studio\\Installer\\vswhere.exe"
		if (!file(vsWhere).exists()) {
			throw new GradleException("Visual Studio Build Tools not found. Please install Visual Studio 2019/2022 with C++ support.")
		}

		def vsPath = ["cmd", "/c", vsWhere, "-latest", "-products", "*", "-requires", "Microsoft.VisualStudio.Component.VC.Tools.x86.x64", "-property", "installationPath"].execute().text.trim()
		if (vsPath.isEmpty()) {
			throw new GradleException("Visual Studio C++ build tools not found.")
		}

		def vcvarsPath = "${vsPath}\\VC\\Auxiliary\\Build\\vcvars64.bat"
		if (!file(vcvarsPath).exists()) {
			throw new GradleException("vcvars64.bat not found at: ${vcvarsPath}")
		}

		println "Compiling DirectX 11 native library with Visual Studio at: ${vsPath}"
		println "RenderDoc integration: Enabled (runtime dynamic loading)"
	}

	// Set up Visual Studio environment and compile DirectX 11
	commandLine 'cmd', '/c', "call \"${System.env['ProgramFiles(x86)']}\\Microsoft Visual Studio\\Installer\\vswhere.exe\" -latest -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -property installationPath > vs_path.txt && " +
		"set /p VS_PATH=<vs_path.txt && " +
		"call \"%VS_PATH%\\VC\\Auxiliary\\Build\\vcvars64.bat\" && " +
		"cl /LD /EHsc /D_DEBUG /MDd /I\"src/main/include\" " +
		"/I\"%JAVA_HOME%\\include\" /I\"%JAVA_HOME%\\include\\win32\" " +
		"\"src/main/cpp/vitra_d3d11.cpp\" " +
		"/Fe:\"$buildDir/native/vitra-native.dll\" " +
		"/link /LIBPATH:\"libs/x64\" d3d11.lib dxgi.lib d3dcompiler.lib dxguid.lib user32.lib Ole32.lib Shell32.lib"

	workingDir projectDir

	doLast {
		println "DirectX 11 native library compiled successfully: ${file("$buildDir/native/vitra-native.dll")}"
	}
}

// DirectX 12 Ultimate native library compilation task
task compileNativeDX12(type: Exec) {
	// Only compile on Windows
	onlyIf { !project.hasProperty('skipNative') && System.getProperty('os.name').toLowerCase().contains('windows') }

	doFirst {
		// Create output directory
		file("$buildDir/native").mkdirs()

		// Check for Visual Studio build tools with Windows 10 SDK
		def vsWhere = "${System.env['ProgramFiles(x86)']}\\Microsoft Visual Studio\\Installer\\vswhere.exe"
		if (!file(vsWhere).exists()) {
			throw new GradleException("Visual Studio Build Tools not found. Please install Visual Studio 2019/2022 with C++ support.")
		}

		def vsPath = ["cmd", "/c", vsWhere, "-latest", "-products", "*", "-requires", "Microsoft.VisualStudio.Component.VC.Tools.x86.x64", "-property", "installationPath"].execute().text.trim()
		if (vsPath.isEmpty()) {
			throw new GradleException("Visual Studio C++ build tools not found.")
		}

		def vcvarsPath = "${vsPath}\\VC\\Auxiliary\\Build\\vcvars64.bat"
		if (!file(vcvarsPath).exists()) {
			throw new GradleException("vcvars64.bat not found at: ${vcvarsPath}")
		}

		println "Compiling DirectX 12 Ultimate native library with Visual Studio at: ${vsPath}"
		println "RenderDoc integration: Enabled (runtime dynamic loading)"
	}

	// Set up Visual Studio environment and compile DirectX 12 Ultimate with D3D12MA
	commandLine 'cmd', '/c', "call \"${System.env['ProgramFiles(x86)']}\\Microsoft Visual Studio\\Installer\\vswhere.exe\" -latest -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -property installationPath > vs_path.txt && " +
		"set /p VS_PATH=<vs_path.txt && " +
		"call \"%VS_PATH%\\VC\\Auxiliary\\Build\\vcvars64.bat\" && " +
		"cl /LD /EHsc /std:c++20 /I\"src/main/include\" /I\"src/main/external/D3D12MA\" " +
		"/I\"%JAVA_HOME%\\include\" /I\"%JAVA_HOME%\\include\\win32\" " +
		"/DVITRA_D3D12MA_AVAILABLE=1 " +
		"\"src/main/cpp/vitra_d3d12.cpp\" \"src/main/external/D3D12MA/D3D12MemAlloc.cpp\" " +
		"/Fe:\"$buildDir/native/vitra-d3d12.dll\" " +
		"/link /LIBPATH:\"libs/x64\" d3d12.lib dxgi.lib d3dcompiler.lib dxcompiler.lib user32.lib Ole32.lib Shell32.lib"

	workingDir projectDir

	doLast {
		println "DirectX 12 Ultimate native library compiled successfully: ${file("$buildDir/native/vitra-d3d12.dll")}"

		// Copy dxcompiler.dll dependency from Windows SDK to build/native
		def windowsKitsPath = "${System.env['ProgramFiles(x86)']}\\Windows Kits\\10"
		def dxcompilerSource = "${windowsKitsPath}\\bin\\10.0.26100.0\\x64\\dxcompiler.dll"

		if (file(dxcompilerSource).exists()) {
			copy {
				from dxcompilerSource
				into "$buildDir/native"
			}
			println "Copied dxcompiler.dll dependency to build/native"
		} else {
			println "WARNING: dxcompiler.dll not found at ${dxcompilerSource}"
			println "DirectX 12 may fail to load. Please install Windows 10 SDK."
		}
	}
}

// Compile all native libraries
task compileNative {
	dependsOn compileNativeDX11, compileNativeDX12
}

// Copy native libraries to resources
task copyNative(type: Copy) {
	dependsOn compileNative
	onlyIf { !project.hasProperty('skipNative') && System.getProperty('os.name').toLowerCase().contains('windows') }

	from "$buildDir/native"
	from "libs/x64"
	into "$buildDir/resources/main/native/windows"
	include "*.dll"

	doFirst {
		// Ensure the target directory exists
		file("$buildDir/resources/main/native/windows").mkdirs()
	}
}

// Also copy to src/main/resources for development (IDE usage)
task copyNativeToSrc(type: Copy) {
	dependsOn compileNative
	onlyIf { !project.hasProperty('skipNative') && System.getProperty('os.name').toLowerCase().contains('windows') }

	from "$buildDir/native"
	from "libs/x64"
	into "src/main/resources/native/windows"
	include "*.dll"

	doFirst {
		// Ensure the target directory exists
		file("src/main/resources/native/windows").mkdirs()
	}
}

// Make processResources depend on shader compilation, copyNative, and copyNativeToSrc
processResources.dependsOn compileShaders, copyNative, copyNativeToSrc

// Make classes task depend on copyNativeToSrc for IDE development
classes.dependsOn copyNativeToSrc

// Make sourcesJar depend on copyNativeToSrc to ensure native libraries are copied first
sourcesJar.dependsOn copyNativeToSrc

// Make sure jar includes the native library
jar {
	dependsOn copyNative
	inputs.property "archivesName", project.base.archivesName

	from("LICENSE") {
		rename { "${it}_${inputs.properties.archivesName}"}
	}

	// Include native library if it exists
	from("$buildDir/resources/main") {
		include "native/windows/*.dll"
		into "native/windows"
	}
}

// configure the maven publication
publishing {
	publications {
		create("mavenJava", MavenPublication) {
			artifactId = project.archives_base_name
			from components.java
		}
	}

	// See https://docs.gradle.org/current/userguide/publishing_maven.html for information on how to set up publishing.
	repositories {
		// Add repositories to publish to here.
		// Notice: This block does NOT have the same function as the block in the top level.
		// The repositories here will be used for publishing your artifact, not for
		// retrieving dependencies.
	}
}
