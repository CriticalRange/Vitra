package com.vitra.mixin.render;

import com.mojang.blaze3d.opengl.GlStateManager;
import com.mojang.blaze3d.systems.RenderSystem;
import com.vitra.VitraMod;
import com.vitra.render.IVitraRenderer;
import com.vitra.render.VitraRenderer;
import org.jetbrains.annotations.Nullable;
import org.lwjgl.system.MemoryUtil;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.Overwrite;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Redirect;

import java.nio.ByteBuffer;
import java.nio.IntBuffer;
import java.util.concurrent.atomic.AtomicInteger;

@Mixin(GlStateManager.class)
public class GlStateManagerMixin {

    // Helper to get renderer instance (with null-safety check)
    // Returns null for D3D12 (which doesn't need GL compatibility layer)
    @Nullable
    private static VitraRenderer getRenderer() {
        IVitraRenderer baseRenderer = VitraMod.getRenderer();
        if (baseRenderer == null) {
            // Not yet initialized - this is expected during early initialization
            return null;
        }

        // If it's already a VitraRenderer (D3D11), return it directly
        if (baseRenderer instanceof VitraRenderer) {
            return (VitraRenderer) baseRenderer;
        }

        // For D3D12, return null (D3D12 doesn't use GL compatibility layer)
        // D3D12 handles rendering directly without going through GL emulation
        return null;
    }

    // Helper for methods that must have a renderer (throws if null)
    private static VitraRenderer getRendererOrThrow() {
        VitraRenderer renderer = getRenderer();
        if (renderer == null) {
            throw new IllegalStateException("VitraRenderer required but not available (D3D12 mode or not initialized)");
        }
        return renderer;
    }

    // ID counters for resource management
    // Note: Texture IDs are managed by D3D11Texture (matches VulkanMod's VkGlTexture pattern)
    private static final AtomicInteger framebufferIdCounter = new AtomicInteger(1);
    private static final AtomicInteger renderbufferIdCounter = new AtomicInteger(1);
    private static final AtomicInteger bufferIdCounter = new AtomicInteger(1);
    private static final AtomicInteger programIdCounter = new AtomicInteger(1);

    // Track bound framebuffer for OpenGL compatibility
    private static int boundFramebuffer = 0;

    // Debug counter for _clearColor logging
    private static int clearColorCount = 0;

    /**
     * @author Vitra (adapted from VulkanMod)
     * @reason Use D3D11Texture system for texture binding
     */
    
    @Overwrite(remap = false)
    public static void _bindTexture(int i) {
        RenderSystem.assertOnRenderThreadOrInit();
        // CRITICAL FIX: Set active texture unit to 0 before binding
        // Without this, textures bind to wrong slot causing texture cycling
        com.vitra.render.jni.VitraD3D11Renderer.setActiveTextureUnit(0);
        // CRITICAL: Bind through D3D11Texture to map OpenGL ID â†’ DirectX handle
        // This is the fix for the yellow screen issue!
        com.vitra.render.D3D11Texture.bindTexture(i);
    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    public static void _disableBlend() {
        RenderSystem.assertOnRenderThread();
        VitraRenderer r = getRenderer(); if (r != null) r.disableBlend();
    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    public static void _enableBlend() {
        RenderSystem.assertOnRenderThread();
        VitraRenderer r = getRenderer(); if (r != null) r.enableBlend();
    }

    /**
     * @author
     */
    
    @Overwrite(remap = false)
    public static void _blendFunc(int i, int j) {
        RenderSystem.assertOnRenderThread();
        VitraRenderer r = getRenderer(); if (r != null) r.blendFunc(i, j);
    }

    /**
     * @author
     */
    
    @Overwrite(remap = false)
    public static void _blendFuncSeparate(int i, int j, int k, int l) {
        RenderSystem.assertOnRenderThread();
        VitraRenderer r = getRenderer(); if (r != null) r.blendFuncSeparate(i, j, k, l);
    }

    /**
     * @author
     */
    
    @Overwrite(remap = false)
    public static void _blendEquation(int i) {
        RenderSystem.assertOnRenderThread();
        VitraRenderer r = getRenderer(); if (r != null) r.blendEquation(i);
    }

    /**
     * @author
     */
    
    @Overwrite(remap = false)
    public static void _disableScissorTest() {
        VitraRenderer r = getRenderer(); if (r != null) r.resetScissor();
    }

    /**
     * @author
     */
    
    @Overwrite(remap = false)
    public static void _enableScissorTest() {
        // No-op - scissor enabled by setScissor call
    }

    /**
     * @author
     */
    
    @Overwrite(remap = false)
    public static void _enableCull() {
        VitraRenderer r = getRenderer(); if (r != null) r.enableCull();
    }

    /**
     * @author
     */
    
    @Overwrite(remap = false)
    public static void _disableCull() {
        VitraRenderer r = getRenderer(); if (r != null) r.disableCull();
    }

    /**
     * @author
     */
    @Redirect(method = "_viewport", at = @At(value = "INVOKE", target = "Lorg/lwjgl/opengl/GL11;glViewport(IIII)V"), remap = false)
    private static void _viewport(int x, int y, int width, int height) {
        VitraRenderer r = getRenderer(); if (r != null) r.setViewport(x, y, width, height);
    }

    // Debug counter for scissor logging
    private static int scissorBoxCount = 0;

    /**
     * @author
     */
    
    @Overwrite(remap = false)
    public static void _scissorBox(int x, int y, int width, int height) {
        // DEBUG: Log first 30 scissor calls to trace where 0x0 comes from
        if (scissorBoxCount < 30) {
            System.out.println("[JAVA_SCISSOR " + scissorBoxCount++ + "] _scissorBox(" + x + ", " + y + ", " + width + ", " + height + ")");
        }
        VitraRenderer r = getRenderer(); if (r != null) r.setScissor(x, y, width, height);
    }

    /**
     * @author
     */
    
    @Overwrite(remap = false)
    public static int _getError() {
        return 0;
    }

    /**
     * @author Vitra (adapted from VulkanMod)
     * @reason Use renderer-aware GlTexture system for proper texture management
     */
    
    @Overwrite(remap = false)
    public static void _texImage2D(int target, int level, int internalFormat, int width, int height, int border, int format, int type, @Nullable IntBuffer pixels) {
        RenderSystem.assertOnRenderThread();

        // Route to correct GlTexture system based on active renderer
        IVitraRenderer baseRenderer = VitraMod.getRenderer();
        if (baseRenderer == null) {
            // Not initialized yet
            return;
        }

        // Convert IntBuffer to ByteBuffer
        ByteBuffer byteBuffer = pixels != null ? MemoryUtil.memByteBuffer(pixels) : null;

        if (baseRenderer instanceof VitraRenderer) {
            // D3D11 path: Use D3D11Texture system
            int boundTextureId = com.vitra.render.D3D11Texture.getBoundTexture(
                com.vitra.render.D3D11Texture.getActiveTextureSlot()
            );
            com.vitra.render.D3D11Texture.texImage2D(
                target, level, internalFormat, width, height, border, format, type, byteBuffer
            );
        } else {
            // D3D12 path: Use D3D12GlTexture system
            int boundTextureId = com.vitra.render.d3d12.D3D12GlTexture.getBoundTexture(
                com.vitra.render.d3d12.D3D12GlTexture.getActiveTextureSlot()
            );
            com.vitra.render.d3d12.D3D12GlTexture.texImage2D(
                boundTextureId, level, internalFormat, width, height, format, type, byteBuffer
            );
        }
    }

    /**
     * @author Vitra (adapted from VulkanMod)
     * @reason Use D3D11Texture system for proper texture management
     */
    
    @Overwrite(remap = false)
    public static void _texSubImage2D(int target, int level, int offsetX, int offsetY, int width, int height, int format, int type, long pixels) {
        RenderSystem.assertOnRenderThread();

        // Update texture subregion in DirectX (matches VulkanMod's VkGlTexture.texSubImage2D pattern)
        com.vitra.render.D3D11Texture.texSubImage2D(
            target, level, offsetX, offsetY, width, height, format, type, pixels
        );
    }

    /**
     * @author Vitra (adapted from VulkanMod)
     * @reason Use D3D11Texture to track active texture slot
     */
    
    @Overwrite(remap = false)
    public static void _activeTexture(int i) {
        RenderSystem.assertOnRenderThreadOrInit();
        // Track active texture slot in D3D11Texture (matches VulkanMod's VkGlTexture pattern)
        com.vitra.render.D3D11Texture.activeTexture(i);
    }

    /**
     * @author
     */
    
    @Overwrite(remap = false)
    public static void _texParameter(int i, int j, int k) {
        VitraRenderer r = getRenderer(); if (r != null) r.texParameteri(i, j, k);
    }

    /**
     * @author
     */
    
    @Overwrite(remap = false)
    public static void _texParameter(int i, int j, float k) {
        VitraRenderer r = getRenderer(); if (r != null) r.setTextureParameterf(i, j, k);
    }

    /**
     * @author
     */
    
    @Overwrite(remap = false)
    public static int _getTexLevelParameter(int i, int j, int k) {
        VitraRenderer r = getRenderer();
        return (r != null) ? r.getTexLevelParameter(i, j, k) : 0;
    }

    /**
     * @author Vitra (adapted from VulkanMod)
     * @reason Use D3D11Texture to track pixel store parameters for texture uploads
     */
    
    @Overwrite(remap = false)
    public static void _pixelStore(int pname, int param) {
        RenderSystem.assertOnRenderThread();

        // Track unpack parameters for D3D11Texture (matches VulkanMod's VkGlTexture pattern)
        final int GL_UNPACK_ROW_LENGTH = 0x0CF2;
        final int GL_UNPACK_SKIP_ROWS = 0x0CF3;
        final int GL_UNPACK_SKIP_PIXELS = 0x0CF4;

        switch (pname) {
            case GL_UNPACK_ROW_LENGTH:
                com.vitra.render.D3D11Texture.setUnpackRowLength(param);
                break;
            case GL_UNPACK_SKIP_ROWS:
                com.vitra.render.D3D11Texture.setUnpackSkipRows(param);
                break;
            case GL_UNPACK_SKIP_PIXELS:
                com.vitra.render.D3D11Texture.setUnpackSkipPixels(param);
                break;
        }

        // Also forward to native renderer for any other pixel store operations
        VitraRenderer r = getRenderer(); if (r != null) r.pixelStore(pname, param);
    }

    /**
     * @author Vitra (adapted from VulkanMod)
     * @reason Use D3D11Texture to generate texture IDs
     */
    
    @Overwrite(remap = false)
    public static int _genTexture() {
        RenderSystem.assertOnRenderThreadOrInit();
        // Generate texture ID through D3D11Texture (matches VulkanMod's VkGlTexture pattern)
        return com.vitra.render.D3D11Texture.genTextureId();
    }

    /**
     * @author Vitra (adapted from VulkanMod)
     * @reason Use D3D11Texture to delete textures and clean up DirectX resources
     */
    
    @Overwrite(remap = false)
    public static void _deleteTexture(int i) {
        RenderSystem.assertOnRenderThread();
        // Delete texture through D3D11Texture which handles DirectX cleanup (matches VulkanMod's VkGlTexture pattern)
        com.vitra.render.D3D11Texture.deleteTexture(i);
    }

    /**
     * @author
     */
    
    @Overwrite(remap = false)
    public static void _colorMask(boolean red, boolean green, boolean blue, boolean alpha) {
        RenderSystem.assertOnRenderThread();
        VitraRenderer r = getRenderer(); if (r != null) r.colorMask(red, green, blue, alpha);
    }

    /**
     * @author
     */
    
    @Overwrite(remap = false)
    public static void _polygonMode(int face, int mode) {
        RenderSystem.assertOnRenderThread();
        VitraRenderer r = getRenderer(); if (r != null) r.setPolygonMode(mode);
    }

    /**
     * @author
     */
    
    @Overwrite(remap = false)
    public static void _enablePolygonOffset() {
        RenderSystem.assertOnRenderThread();
        VitraRenderer r = getRenderer(); if (r != null) r.enablePolygonOffset();
    }

    /**
     * @author
     */
    
    @Overwrite(remap = false)
    public static void _disablePolygonOffset() {
        RenderSystem.assertOnRenderThread();
        VitraRenderer r = getRenderer(); if (r != null) r.disablePolygonOffset();
    }

    /**
     * @author
     */
    
    @Overwrite(remap = false)
    public static void _polygonOffset(float f, float g) {
        RenderSystem.assertOnRenderThread();
        VitraRenderer r = getRenderer(); if (r != null) r.polygonOffset(f, g);
    }

    /**
     * @author
     */
    
    @Overwrite(remap = false)
    public static void _enableColorLogicOp() {
        RenderSystem.assertOnRenderThread();
        VitraRenderer r = getRenderer(); if (r != null) r.enableColorLogicOp();
    }

    /**
     * @author
     */
    
    @Overwrite(remap = false)
    public static void _disableColorLogicOp() {
        RenderSystem.assertOnRenderThread();
        VitraRenderer r = getRenderer(); if (r != null) r.disableColorLogicOp();
    }

    /**
     * @author
     */
    
    @Overwrite(remap = false)
    public static void _logicOp(int i) {
        RenderSystem.assertOnRenderThread();
        VitraRenderer r = getRenderer(); if (r != null) r.logicOp(i);
    }

    /**
     * @author
     */
    
    @Overwrite(remap = false)
    public static void _clearColor(float f, float g, float h, float i) {
        RenderSystem.assertOnRenderThreadOrInit();

        // DEBUG: Log first 20 _clearColor calls
        if (clearColorCount < 20) {
            System.out.println("[JAVA_CLEARCOLOR " + clearColorCount + "] _clearColor(" + f + ", " + g + ", " + h + ", " + i + ")");
            clearColorCount++;
        }

        VitraRenderer r = getRenderer(); if (r != null) r.setClearColor(f, g, h, i);
    }

    /**
     * @author
     */
    
    @Overwrite(remap = false)
    public static void _clearDepth(double d) {
        RenderSystem.assertOnRenderThread();
        VitraRenderer r = getRenderer(); if (r != null) r.clearDepth((float) d);
    }

    /**
     * @author
     */
    
    @Overwrite(remap = false)
    public static void _clear(int mask, boolean bl) {
        RenderSystem.assertOnRenderThread();
        System.out.println("[JAVA_CLEAR] _clear() called with mask=0x" + Integer.toHexString(mask) + ", bl=" + bl);
        VitraRenderer renderer = getRenderer();
        if (renderer != null) {
            renderer.clear(mask);
        }
        // No-op for D3D12 or if not initialized yet
    }

    // Debug counters for depth state logging
    private static int depthTestCount = 0;
    private static int depthMaskCount = 0;
    private static int depthFuncCount = 0;

    /**
     * @author
     */
    
    @Overwrite(remap = false)
    public static void _disableDepthTest() {
        RenderSystem.assertOnRenderThread();
        if (depthTestCount < 30) {
            System.out.println("[DEPTH_TEST " + depthTestCount++ + "] DISABLED");
        }
        VitraRenderer r = getRenderer(); if (r != null) r.disableDepthTest();
    }

    /**
     * @author
     */
    
    @Overwrite(remap = false)
    public static void _enableDepthTest() {
        RenderSystem.assertOnRenderThread();
        if (depthTestCount < 30) {
            System.out.println("[DEPTH_TEST " + depthTestCount++ + "] ENABLED");
        }
        VitraRenderer r = getRenderer(); if (r != null) r.enableDepthTest();
    }

    /**
     * @author
     */
    
    @Overwrite(remap = false)
    public static void _depthFunc(int i) {
        RenderSystem.assertOnRenderThreadOrInit();
        if (depthFuncCount < 30) {
            System.out.println("[DEPTH_FUNC " + depthFuncCount++ + "] func=0x" + Integer.toHexString(i));
        }
        VitraRenderer r = getRenderer(); if (r != null) r.depthFunc(i);
    }

    /**
     * @author
     */
    
    @Overwrite(remap = false)
    public static void _depthMask(boolean bl) {
        RenderSystem.assertOnRenderThread();
        if (depthMaskCount < 30) {
            System.out.println("[DEPTH_MASK " + depthMaskCount++ + "] mask=" + bl);
        }
        VitraRenderer r = getRenderer(); if (r != null) r.depthMask(bl);

    }

    /**
     * @author
     */
    
    @Overwrite(remap = false)
    public static int glGenFramebuffers() {
        RenderSystem.assertOnRenderThread();
        return framebufferIdCounter.getAndIncrement();
    }

    /**
     * @author
     */
    
    @Overwrite(remap = false)
    public static int glGenRenderbuffers() {
        RenderSystem.assertOnRenderThreadOrInit();
        return renderbufferIdCounter.getAndIncrement();
    }

    /**
     * @author
     */
    
    @Overwrite(remap = false)
    public static void _glBindFramebuffer(int i, int j) {
        RenderSystem.assertOnRenderThread();
        boundFramebuffer = j;
        VitraRenderer r = getRenderer(); if (r != null) r.bindFramebuffer(i, j);
    }

    /**
     * @author
     */
    
    @Overwrite(remap = false)
    public static void _glFramebufferTexture2D(int i, int j, int k, int l, int m) {
        RenderSystem.assertOnRenderThread();
        VitraRenderer r = getRenderer(); if (r != null) r.framebufferTexture2D(i, j, k, l, m);
    }

    /**
     * @author
     */
    
    @Overwrite(remap = false)
    public static void _glBindRenderbuffer(int i, int j) {
        RenderSystem.assertOnRenderThreadOrInit();
        VitraRenderer r = getRenderer(); if (r != null) r.bindRenderbuffer(i, j);
    }

    /**
     * @author
     */
    
    @Overwrite(remap = false)
    public static void _glFramebufferRenderbuffer(int i, int j, int k, int l) {
        RenderSystem.assertOnRenderThreadOrInit();
        VitraRenderer r = getRenderer(); if (r != null) r.framebufferRenderbuffer(i, j, k, l);
    }

    /**
     * @author
     */
    
    @Overwrite(remap = false)
    public static void _glRenderbufferStorage(int i, int j, int k, int l) {
        RenderSystem.assertOnRenderThreadOrInit();
        VitraRenderer r = getRenderer(); if (r != null) r.renderbufferStorage(i, j, k, l);
    }

    /**
     * @author
     */
    
    @Overwrite(remap = false)
    public static int glCheckFramebufferStatus(int i) {
        RenderSystem.assertOnRenderThreadOrInit();
        // Use currently bound framebuffer handle (0 means main framebuffer)
        VitraRenderer r = getRenderer();
        return (r != null) ? r.checkFramebufferStatus(boundFramebuffer, i) : 0x8CD5; // GL_FRAMEBUFFER_COMPLETE
    }

    /**
     * @author
     */
    
    @Overwrite(remap = false)
    public static int _glGenBuffers() {
        RenderSystem.assertOnRenderThreadOrInit();
        // Delegate to GL15M which handles pixel buffers
        return org.lwjgl.opengl.GL15.glGenBuffers();
    }

    /**
     * @author
     */
    
    @Overwrite(remap = false)
    public static void _glBindBuffer(int i, int j) {
        RenderSystem.assertOnRenderThread();
        // Delegate to GL15M which handles pixel buffers
        org.lwjgl.opengl.GL15.glBindBuffer(i, j);
    }

    /**
     * @author
     */
    
    @Overwrite(remap = false)
    public static void _glBufferData(int i, ByteBuffer byteBuffer, int j) {
        RenderSystem.assertOnRenderThread();
        // Delegate to GL15M which handles pixel buffers
        org.lwjgl.opengl.GL15.glBufferData(i, byteBuffer, j);
    }

    /**
     * @author
     */
    
    @Overwrite(remap = false)
    public static void _glBufferData(int i, long l, int j) {
        RenderSystem.assertOnRenderThread();
        // Delegate to GL15M which handles pixel buffers
        org.lwjgl.opengl.GL15.glBufferData(i, l, j);
    }

    /**
     * @author
     */
    
    @Overwrite(remap = false)
    @Nullable
    public static ByteBuffer _glMapBuffer(int i, int j) {
        RenderSystem.assertOnRenderThreadOrInit();
        // Delegate to GL15M which handles pixel buffers
        return org.lwjgl.opengl.GL15.glMapBuffer(i, j);
    }

    /**
     * @author
     */
    
    @Overwrite(remap = false)
    public static void _glUnmapBuffer(int i) {
        RenderSystem.assertOnRenderThread();
        // Delegate to GL15M which handles pixel buffers
        org.lwjgl.opengl.GL15.glUnmapBuffer(i);
    }

    /**
     * @author
     */
    
    @Overwrite(remap = false)
    public static void _glDeleteBuffers(int i) {
        RenderSystem.assertOnRenderThread();
        // Delegate to GL15M which handles pixel buffers
        org.lwjgl.opengl.GL15.glDeleteBuffers(i);
    }

    /**
     * @author
     */
    
    @Overwrite(remap = false)
    public static void _disableVertexAttribArray(int i) {
        // No-op for DirectX - vertex attributes handled differently
    }

    /**
     * @author
     */
    
    @Overwrite(remap = false)
    public static void _glUseProgram(int i) {
        RenderSystem.assertOnRenderThread();
        VitraRenderer r = getRenderer(); if (r != null) r.useProgram(i);
    }

    /**
     * @author
     */
    
    @Overwrite(remap = false)
    public static int glCreateProgram() {
        RenderSystem.assertOnRenderThread();
        return programIdCounter.getAndIncrement();
    }

    /**
     * @author
     */
    
    @Overwrite(remap = false)
    public static void glDeleteProgram(int i) {
        RenderSystem.assertOnRenderThread();
        VitraRenderer r = getRenderer(); if (r != null) r.deleteProgram(i);
    }

    /**
     * @author
     */
    
    @Overwrite(remap = false)
    public static int _glGenVertexArrays() {
        RenderSystem.assertOnRenderThreadOrInit();
        // DirectX doesn't use VAOs - return dummy ID
        return 1;
    }
}
