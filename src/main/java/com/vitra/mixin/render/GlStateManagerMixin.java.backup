package com.vitra.mixin.render;

import com.mojang.blaze3d.platform.GlStateManager;
import com.mojang.blaze3d.systems.RenderSystem;
import com.vitra.VitraMod;
import com.vitra.render.IVitraRenderer;
import com.vitra.render.VitraRenderer;
import org.jetbrains.annotations.Nullable;
import org.lwjgl.system.MemoryUtil;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.Overwrite;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Redirect;

import java.nio.ByteBuffer;
import java.nio.IntBuffer;
import java.util.concurrent.atomic.AtomicInteger;

@Mixin(GlStateManager.class)
public class GlStateManagerMixin {

    // Helper to get renderer instance (with null-safety check)
    // Returns null for D3D12 (which doesn't need GL compatibility layer)
    @Nullable
    private static VitraRenderer getRenderer() {
        IVitraRenderer baseRenderer = VitraMod.getRenderer();
        if (baseRenderer == null) {
            // Not yet initialized - this is expected during early initialization
            return null;
        }

        // If it's already a VitraRenderer (D3D11), return it directly
        if (baseRenderer instanceof VitraRenderer) {
            return (VitraRenderer) baseRenderer;
        }

        // For D3D12, return null (D3D12 doesn't use GL compatibility layer)
        // D3D12 handles rendering directly without going through GL emulation
        return null;
    }

    // ID counters for resource management
    // Note: Texture IDs are managed by D3D11GlTexture (matches VulkanMod's VkGlTexture pattern)
    private static final AtomicInteger framebufferIdCounter = new AtomicInteger(1);
    private static final AtomicInteger renderbufferIdCounter = new AtomicInteger(1);
    private static final AtomicInteger bufferIdCounter = new AtomicInteger(1);
    private static final AtomicInteger programIdCounter = new AtomicInteger(1);

    // Track bound framebuffer for OpenGL compatibility
    private static int boundFramebuffer = 0;

    // Debug counter for _clearColor logging
    private static int clearColorCount = 0;

    /**
     * @author Vitra (adapted from VulkanMod)
     * @reason Use D3D11GlTexture system for texture binding
     */
    @Overwrite(remap = false)
    public static void _bindTexture(int i) {
        RenderSystem.assertOnRenderThreadOrInit();
        // CRITICAL: Bind through D3D11GlTexture to map OpenGL ID â†’ DirectX handle
        // This is the fix for the yellow screen issue!
        com.vitra.render.d3d11.D3D11GlTexture.bindTexture(i);
    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    public static void _disableBlend() {
        RenderSystem.assertOnRenderThread();
        getRenderer().disableBlend();
    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    public static void _enableBlend() {
        RenderSystem.assertOnRenderThread();
        getRenderer().enableBlend();
    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    public static void _blendFunc(int i, int j) {
        RenderSystem.assertOnRenderThread();
        getRenderer().blendFunc(i, j);
    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    public static void _blendFuncSeparate(int i, int j, int k, int l) {
        RenderSystem.assertOnRenderThread();
        getRenderer().blendFuncSeparate(i, j, k, l);
    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    public static void _blendEquation(int i) {
        RenderSystem.assertOnRenderThread();
        getRenderer().blendEquation(i);
    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    public static void _disableScissorTest() {
        getRenderer().resetScissor();
    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    public static void _enableScissorTest() {
        // No-op - scissor enabled by setScissor call
    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    public static void _enableCull() {
        getRenderer().enableCull();
    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    public static void _disableCull() {
        getRenderer().disableCull();
    }

    /**
     * @author
     */
    @Redirect(method = "_viewport", at = @At(value = "INVOKE", target = "Lorg/lwjgl/opengl/GL11;glViewport(IIII)V"), remap = false)
    private static void _viewport(int x, int y, int width, int height) {
        getRenderer().setViewport(x, y, width, height);
    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    public static void _scissorBox(int x, int y, int width, int height) {
        getRenderer().setScissor(x, y, width, height);
    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    public static int _getError() {
        return 0;
    }

    /**
     * @author Vitra (adapted from VulkanMod)
     * @reason Use D3D11GlTexture system for proper texture management
     */
    @Overwrite(remap = false)
    public static void _texImage2D(int target, int level, int internalFormat, int width, int height, int border, int format, int type, @Nullable IntBuffer pixels) {
        RenderSystem.assertOnRenderThread();

        // Get currently bound texture ID from D3D11GlTexture
        int boundTextureId = com.vitra.render.d3d11.D3D11GlTexture.getBoundTexture(
            com.vitra.render.d3d11.D3D11GlTexture.getActiveTextureSlot()
        );

        // Convert IntBuffer to ByteBuffer for D3D11GlTexture
        ByteBuffer byteBuffer = pixels != null ? MemoryUtil.memByteBuffer(pixels) : null;

        // Upload texture data to DirectX 11 (matches VulkanMod's VkGlTexture.texImage2D pattern)
        com.vitra.render.d3d11.D3D11GlTexture.texImage2D(
            boundTextureId, level, internalFormat, width, height, format, type, byteBuffer
        );
    }

    /**
     * @author Vitra (adapted from VulkanMod)
     * @reason Use D3D11GlTexture system for proper texture management
     */
    @Overwrite(remap = false)
    public static void _texSubImage2D(int target, int level, int offsetX, int offsetY, int width, int height, int format, int type, long pixels) {
        RenderSystem.assertOnRenderThread();

        // Get currently bound texture ID from D3D11GlTexture
        int boundTextureId = com.vitra.render.d3d11.D3D11GlTexture.getBoundTexture(
            com.vitra.render.d3d11.D3D11GlTexture.getActiveTextureSlot()
        );

        // Convert long pointer to ByteBuffer
        ByteBuffer byteBuffer = pixels != 0 ? MemoryUtil.memByteBuffer(pixels, width * height * 4) : null;

        // Update texture subregion in DirectX 11 (matches VulkanMod's VkGlTexture.texSubImage2D pattern)
        com.vitra.render.d3d11.D3D11GlTexture.texSubImage2D(
            boundTextureId, level, offsetX, offsetY, width, height, format, type, byteBuffer
        );
    }

    /**
     * @author Vitra (adapted from VulkanMod)
     * @reason Use D3D11GlTexture to track active texture slot
     */
    @Overwrite(remap = false)
    public static void _activeTexture(int i) {
        RenderSystem.assertOnRenderThreadOrInit();
        // Track active texture slot in D3D11GlTexture (matches VulkanMod's VkGlTexture pattern)
        com.vitra.render.d3d11.D3D11GlTexture.activeTexture(i);
    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    public static void _texParameter(int i, int j, int k) {
        getRenderer().texParameteri(i, j, k);
    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    public static void _texParameter(int i, int j, float k) {
        getRenderer().setTextureParameterf(i, j, k);
    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    public static int _getTexLevelParameter(int i, int j, int k) {
        return getRenderer().getTexLevelParameter(i, j, k);
    }

    /**
     * @author Vitra (adapted from VulkanMod)
     * @reason Use D3D11GlTexture to track pixel store parameters for texture uploads
     */
    @Overwrite(remap = false)
    public static void _pixelStore(int pname, int param) {
        RenderSystem.assertOnRenderThread();

        // Track unpack parameters for D3D11GlTexture (matches VulkanMod's VkGlTexture pattern)
        final int GL_UNPACK_ROW_LENGTH = 0x0CF2;
        final int GL_UNPACK_SKIP_ROWS = 0x0CF3;
        final int GL_UNPACK_SKIP_PIXELS = 0x0CF4;

        switch (pname) {
            case GL_UNPACK_ROW_LENGTH:
                com.vitra.render.d3d11.D3D11GlTexture.setUnpackRowLength(param);
                break;
            case GL_UNPACK_SKIP_ROWS:
                com.vitra.render.d3d11.D3D11GlTexture.setUnpackSkipRows(param);
                break;
            case GL_UNPACK_SKIP_PIXELS:
                com.vitra.render.d3d11.D3D11GlTexture.setUnpackSkipPixels(param);
                break;
        }

        // Also forward to native renderer for any other pixel store operations
        getRenderer().pixelStore(pname, param);
    }

    /**
     * @author Vitra (adapted from VulkanMod)
     * @reason Use D3D11GlTexture to generate texture IDs
     */
    @Overwrite(remap = false)
    public static int _genTexture() {
        RenderSystem.assertOnRenderThreadOrInit();
        // Generate texture ID through D3D11GlTexture (matches VulkanMod's VkGlTexture pattern)
        return com.vitra.render.d3d11.D3D11GlTexture.genTextureId();
    }

    /**
     * @author Vitra (adapted from VulkanMod)
     * @reason Use D3D11GlTexture to delete textures and clean up DirectX resources
     */
    @Overwrite(remap = false)
    public static void _deleteTexture(int i) {
        RenderSystem.assertOnRenderThread();
        // Delete texture through D3D11GlTexture which handles DirectX cleanup (matches VulkanMod's VkGlTexture pattern)
        com.vitra.render.d3d11.D3D11GlTexture.deleteTexture(i);
    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    public static void _colorMask(boolean red, boolean green, boolean blue, boolean alpha) {
        RenderSystem.assertOnRenderThread();
        getRenderer().colorMask(red, green, blue, alpha);
    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    public static void _polygonMode(int face, int mode) {
        RenderSystem.assertOnRenderThread();
        getRenderer().setPolygonMode(mode);
    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    public static void _enablePolygonOffset() {
        RenderSystem.assertOnRenderThread();
        getRenderer().enablePolygonOffset();
    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    public static void _disablePolygonOffset() {
        RenderSystem.assertOnRenderThread();
        getRenderer().disablePolygonOffset();
    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    public static void _polygonOffset(float f, float g) {
        RenderSystem.assertOnRenderThread();
        getRenderer().polygonOffset(f, g);
    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    public static void _enableColorLogicOp() {
        RenderSystem.assertOnRenderThread();
        getRenderer().enableColorLogicOp();
    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    public static void _disableColorLogicOp() {
        RenderSystem.assertOnRenderThread();
        getRenderer().disableColorLogicOp();
    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    public static void _logicOp(int i) {
        RenderSystem.assertOnRenderThread();
        getRenderer().logicOp(i);
    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    public static void _clearColor(float f, float g, float h, float i) {
        RenderSystem.assertOnRenderThreadOrInit();

        // DEBUG: Log first 20 _clearColor calls
        if (clearColorCount < 20) {
            System.out.println("[JAVA_CLEARCOLOR " + clearColorCount + "] _clearColor(" + f + ", " + g + ", " + h + ", " + i + ")");
            clearColorCount++;
        }

        getRenderer().setClearColor(f, g, h, i);
    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    public static void _clearDepth(double d) {
        RenderSystem.assertOnRenderThread();
        getRenderer().clearDepth((float) d);
    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    public static void _clear(int mask, boolean bl) {
        RenderSystem.assertOnRenderThread();
        System.out.println("[JAVA_CLEAR] _clear() called with mask=0x" + Integer.toHexString(mask) + ", bl=" + bl);
        VitraRenderer renderer = getRenderer();
        if (renderer != null) {
            renderer.clear(mask);
        }
        // No-op for D3D12 or if not initialized yet
    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    public static void _disableDepthTest() {
        RenderSystem.assertOnRenderThread();
        getRenderer().disableDepthTest();
    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    public static void _enableDepthTest() {
        RenderSystem.assertOnRenderThread();
        getRenderer().enableDepthTest();
    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    public static void _depthFunc(int i) {
        RenderSystem.assertOnRenderThreadOrInit();
        getRenderer().depthFunc(i);
    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    public static void _depthMask(boolean bl) {
        RenderSystem.assertOnRenderThread();
        getRenderer().depthMask(bl);

    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    public static int glGenFramebuffers() {
        RenderSystem.assertOnRenderThread();
        return framebufferIdCounter.getAndIncrement();
    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    public static int glGenRenderbuffers() {
        RenderSystem.assertOnRenderThreadOrInit();
        return renderbufferIdCounter.getAndIncrement();
    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    public static void _glBindFramebuffer(int i, int j) {
        RenderSystem.assertOnRenderThread();
        boundFramebuffer = j;
        getRenderer().bindFramebuffer(i, j);
    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    public static void _glFramebufferTexture2D(int i, int j, int k, int l, int m) {
        RenderSystem.assertOnRenderThread();
        getRenderer().framebufferTexture2D(i, j, k, l, m);
    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    public static void _glBindRenderbuffer(int i, int j) {
        RenderSystem.assertOnRenderThreadOrInit();
        getRenderer().bindRenderbuffer(i, j);
    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    public static void _glFramebufferRenderbuffer(int i, int j, int k, int l) {
        RenderSystem.assertOnRenderThreadOrInit();
        getRenderer().framebufferRenderbuffer(i, j, k, l);
    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    public static void _glRenderbufferStorage(int i, int j, int k, int l) {
        RenderSystem.assertOnRenderThreadOrInit();
        getRenderer().renderbufferStorage(i, j, k, l);
    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    public static int glCheckFramebufferStatus(int i) {
        RenderSystem.assertOnRenderThreadOrInit();
        // Use currently bound framebuffer handle (0 means main framebuffer)
        return getRenderer().checkFramebufferStatus(boundFramebuffer, i);
    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    public static int _glGenBuffers() {
        RenderSystem.assertOnRenderThreadOrInit();
        // Delegate to GL15M which handles pixel buffers
        return org.lwjgl.opengl.GL15.glGenBuffers();
    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    public static void _glBindBuffer(int i, int j) {
        RenderSystem.assertOnRenderThread();
        // Delegate to GL15M which handles pixel buffers
        org.lwjgl.opengl.GL15.glBindBuffer(i, j);
    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    public static void _glBufferData(int i, ByteBuffer byteBuffer, int j) {
        RenderSystem.assertOnRenderThread();
        // Delegate to GL15M which handles pixel buffers
        org.lwjgl.opengl.GL15.glBufferData(i, byteBuffer, j);
    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    public static void _glBufferData(int i, long l, int j) {
        RenderSystem.assertOnRenderThread();
        // Delegate to GL15M which handles pixel buffers
        org.lwjgl.opengl.GL15.glBufferData(i, l, j);
    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    @Nullable
    public static ByteBuffer _glMapBuffer(int i, int j) {
        RenderSystem.assertOnRenderThreadOrInit();
        // Delegate to GL15M which handles pixel buffers
        return org.lwjgl.opengl.GL15.glMapBuffer(i, j);
    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    public static void _glUnmapBuffer(int i) {
        RenderSystem.assertOnRenderThread();
        // Delegate to GL15M which handles pixel buffers
        org.lwjgl.opengl.GL15.glUnmapBuffer(i);
    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    public static void _glDeleteBuffers(int i) {
        RenderSystem.assertOnRenderThread();
        // Delegate to GL15M which handles pixel buffers
        org.lwjgl.opengl.GL15.glDeleteBuffers(i);
    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    public static void _disableVertexAttribArray(int i) {
        // No-op for DirectX 11 - vertex attributes handled differently
    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    public static void _glUseProgram(int i) {
        RenderSystem.assertOnRenderThread();
        getRenderer().useProgram(i);
    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    public static int glCreateProgram() {
        RenderSystem.assertOnRenderThread();
        return programIdCounter.getAndIncrement();
    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    public static void glDeleteProgram(int i) {
        RenderSystem.assertOnRenderThread();
        getRenderer().deleteProgram(i);
    }

    /**
     * @author
     */
    @Overwrite(remap = false)
    public static int _glGenVertexArrays() {
        RenderSystem.assertOnRenderThreadOrInit();
        // DirectX 11 doesn't use VAOs - return dummy ID
        return 1;
    }
}
